#include <iostream>

using namespace std;

int main()
{
    short int A[15] = { 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000 };
    short int B[15] = { 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000 };
    int* C[26] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; //Всегда под двойное слово автоматически, если *
    int k = 0; // Количество троек

    _asm {
        lea esi, A; // Создаем указатель на первый элемент массива А в esi
        lea edi, B; // Создаем указатель на первый элемент массива В в edi
        lea ebx, C; // Создаем указатель на первый элемент массива В в ebx
        mov ecx, 15; // Создаем счетчик в еcx
    
    START:
        mov ax, [esi + 2]; // Сохраняем значение второго элемента тройки из А в ax
        mov dx, [edi + 2]; // Сохраняем значение второго элемента тройки из В в dx

        cmp ax, dx; // Сравниваем значения вторых элементов из троек А и В
        jne NEXT; // Если они не равны, переходим на следующую тройку

        mov ax, [esi]; // Сохраняем значение первого элемента тройки из А в ax
        add ax, [esi + 4]; // Добавляем значение третьего элемента к первому элементу тройки из А, значение суммы - в ax
        mov dx, [edi]; // Сохраняем значение первого элемента тройки из B в dx
        add dx, [edi + 4]; // Добавляем значение третьего элемента к первому элементу тройки из B, значение суммы - в dx

        cmp ax, dx; // Сравниваем значения сумм элементов из троек А и В
        jne NEXT; // Если они не равны, переходим на следующую тройку

        inc k; // Увеличиваем количество троек на 1

        mov eax, esi; // Сохраняем значение первого элемента тройки из А в eax
        add eax, 2; // Увеличиваем указатель на 1
        mov[ebx], eax; // Сохраняем в массиве С адрес второго элемента из тройки А
        add ebx, 4; // Сдвигаем указатель С на 1 элемент

        mov eax, edi; // Сохраняем значение первого элемента тройки из В в eax
        add eax, 2; // Увеличиваем указатель на 1
        mov[ebx], eax; // Сохраняем в массиве С адрес второго элемента из тройки В
        add ebx, 4; // Сдвигаем указатель С на 1 элемент

        jmp NEXT; // Переходим на следующую тройку

    NEXT:
        add esi, 2; // Сдвигаем указатель массива А на 1 элемент
        add edi, 2; // Сдвигаем указатель массива В на 1 элемент
        dec ecx; // Уменьшаем счётчик на 1

        cmp ecx, 2; // Проверяем, что у нас осталась минимум 1 тройка
        jne START; // Если да, то переходим к следующей тройке, если нет, выполнение цикла заканчивается
    }

    cout << k << endl;
    cout << endl;
    int i = 0;

    for (i = 0; i < 26; ++i) {
        if (i < 15) {
            printf("%8x  %5hd  %8x  %5hd  %8x", &A[i], A[i], &B[i], B[i], C[i]);
        }
        else {
            printf("%42x", C[i]);
        }
        cout << endl;
    }
    return 0;
}
